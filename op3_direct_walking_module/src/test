 Eigen::VectorXd cur_jnt_pos(6);
  cur_jnt_pos << 0.0, 0.0, 0.0001, 0.001, 0.00001, 0.0001;
  Eigen::VectorXd des_jnt_pos(6);
  des_jnt_pos << 0.0, 0.0, 0.0, 0.0, 0.0, 0.0;

  Eigen::Matrix4d des_leg_pose;

  des_leg_pose << 1.0, 0.0, 0.0, 0.0,
                  0.0, 1.0, 0.0, 0.0,
                  0.0, 0.0, 1.0, 0.1547,
                  0.0, 0.0, 0.0, 1.0;

  kin_solver->solveIK(kin_solver->RIGHT, cur_jnt_pos, des_leg_pose, des_jnt_pos);

  std::cout<<des_jnt_pos<<std::endl<<std::endl;

  Eigen::Matrix4d fk_matrix;
  des_jnt_pos << -0.004893968363557377,
                 -0.0016859737079686354,
                  1.2125839205546942,
                 -2.536175241899577,
                 -1.2178744571252365,
                 -0.00260789886391688;

  kin_solver->solveFK(kin_solver->RIGHT, des_jnt_pos, fk_matrix);

  std::cout<<fk_matrix<<std::endl<<std::endl;

  des_jnt_pos << -0.0,
                 -0.492022,
                  1.22732,
                 -2.45463                 ,
                 -1.22732,
                 -0.492022;

  kin_solver->solveFK(kin_solver->RIGHT, des_jnt_pos, fk_matrix);

  std::cout<<fk_matrix<<std::endl<<std::endl;


  Eigen::Matrix4d fp_T;
  fp_T << 1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.215,
          0.0, 0.0, 0.0, 1.0;

  Eigen::Matrix4d pf_T;
  pf_T = tr_gen->getInverseTransform(fp_T);

  Eigen::Matrix4d wf_T;
  wf_T = pelvis_pose * pf_T;

  std::cout<<wf_T<<std::endl<<std::endl;

  Eigen::Matrix4d tr_matr;
  tr_matr << 0.6114177, -0.6295392,  0.4794255, 0.0,
             0.7840258,  0.5639544, -0.2593434, 0.0,
            -0.1071073,  0.5344491,  0.8383867, 0.0,
                   0.0,        0.0,        0.0, 1.0;

 Eigen::Vector3d rpy1;
 rpy1 = tr_gen->getRPY(tr_matr);

 std::cout<<rpy1<<std::endl<<std::endl;

 Eigen::Vector3d rpy(0.3, 0.5, 0.8);

 std::cout<<tr_gen->rpyToRotM(rpy)<<std::endl<<std::endl;

void TrajectoryGenerator::comTranslation(leg_type leg, Eigen::Matrix4d goal_pose)
{
  if(leg == RIGHT){
    rleg_traj.push_back(pelvis_pose * this->getInverseTransform(goal_pose));
  }

  if(leg == LEFT){
    lleg_traj.push_back(pelvis_pose * this->getInverseTransform(goal_pose));
  }

}

void TrajectoryGenerator::managerEmulator(double operating_rate, double duration, Eigen::Matrix4d goal_pose)
{
  unsigned int num_steps = (unsigned int) duration * operating_rate;

  // Get Roll Pitch Yaw from init_pose-matrix
  Eigen::Matrix3d r_init;
  r_init = pelvis_pose.block(0,0,3,3);
  Eigen::Vector3d rpy_init;
  rpy_init = this->getRPY(r_init);

  // Get Roll Pitch Yaw from goal_pose-matrix
  Eigen::Matrix3d r_goal;
  r_goal = goal_pose.block(0,0,3,3);
  Eigen::Vector3d rpy_goal;
  rpy_goal = this->getRPY(r_goal);

  // Get differences for RPY
  Eigen::Vector3d delta_rpy;
  delta_rpy = (rpy_goal - rpy_init)/num_steps;

  Eigen::Matrix3d delta_rot;
  delta_rot = this->rpyToRotM(delta_rpy);

  // Differences for translation vector
  Eigen::Vector3d delta_vec;
  delta_vec << (goal_pose(0,3) - pelvis_pose(0,3))/num_steps,
               (goal_pose(1,3) - pelvis_pose(1,3))/num_steps,
               (goal_pose(2,3) - pelvis_pose(2,3))/num_steps;

  // Transformation matrix of differences
  Eigen::Matrix4d delta_transf;
  delta_transf << delta_rot(0,0), delta_rot(0,1), delta_rot(0,2), delta_vec(0),
                  delta_rot(1,0), delta_rot(1,1), delta_rot(1,2), delta_vec(1),
                  delta_rot(2,0), delta_rot(2,1), delta_rot(2,2), delta_vec(2),
                             0.0,            0.0,            0.0,          1.0;

  Eigen::Matrix4d cur_pose;
  cur_pose = pelvis_pose;

  this->comTranslation(this->RIGHT, cur_pose * rfoot_pose);
  this->comTranslation(this->LEFT, cur_pose * lfoot_pose);

  for(unsigned int i=0; i<num_steps; i++)
  {
    cur_pose = delta_transf * cur_pose;

    this->comTranslation(this->RIGHT, cur_pose * rfoot_pose);
    this->comTranslation(this->LEFT, cur_pose * lfoot_pose);

  }

  pelvis_pose = goal_pose;

}


